#include <iostream>
#include "permutation.h"
#include "privatekeygenerator.h"
#include "protocol.h"
#include <fstream>
#include <set>
#include <algorithm>
#include "sims.h"

template< size_t size>
typename std::bitset<size> random_bitset()
{
    typename std::bitset<size> bits;
    std::random_device rd;
    std::mt19937 gen( rd());
    std::bernoulli_distribution d(0.5);

    for( int n = 0; n < size; ++n)
    {
        bits[n] = d(gen);
    }

    return bits;
}

template<size_t N>
std::ostream& operator<<(std::ostream& os, const std::bitset<N> &bits)
{
    for (int i = N-1; i >= 0; i--)
        os << bits[i];
    return os;
}

std::ostream& operator<<(std::ostream& os, const std::set<int> &s)
{
    std::cout << "{";
    for (auto e : s)
        std::cout << e << ", ";
    std::cout << "}\n";
    return os;
}

template<size_t n>
std::vector<BasicPermutation<n>> operator*(std::vector<BasicPermutation<n>> vec1, std::vector<BasicPermutation<n>> vec2)
{
    std::vector<BasicPermutation<n>> product;

    for (auto p1 : vec1)
    {
        for (auto p2 : vec2)
        {
            product.push_back(p1*p2);
        }
    }
    return product;
}

template<size_t n>
std::vector<Permutation<n>> operator*(std::vector<Permutation<n>> vec1, std::vector<Permutation<n>> vec2)
{
    std::vector<Permutation<n>> product;

    for (auto p1 : vec1)
    {
        for (auto p2 : vec2)
        {
            product.push_back(p1*p2);
        }
    }
    return product;
}

template<size_t n>
std::vector<Permutation<n>> zip(std::vector<BasicPermutation<n>> vec1, std::vector<BasicPermutation<n>> vec2)
{
    if (vec1.size() != vec2.size())
        throw std::invalid_argument("Vector sizes must be equal");
    std::vector<Permutation<n>> zipped;
    for (int i = 0; i < vec1.size(); i++)
    {
        zipped.push_back(Permutation<n>(vec1[i], vec2[i]));
    }
    return zipped;
}

template<size_t n>
std::vector<Permutation<n>> mirror(std::vector<Permutation<n>> vec)
{
    std::vector<Permutation<n>> mirrored;
    std::for_each(vec.begin(), vec.end(), [&mirrored](Permutation<n> p) {
        mirrored.push_back(p.mirror());
    });
    return mirrored;
}

template <typename T, std::size_t N>
std::vector<T> concatenateSquareMatrix(const std::array<std::array<T, N>, N>& matrix) {
    std::vector<T> concatenated;
    concatenated.reserve(N * N); // Reserve space for efficiency

    // Iterate over each row of the matrix
    for (const auto& row : matrix) {
        // Insert each element of the row into the vector
        concatenated.insert(concatenated.end(), row.begin(), row.end());
    }

    return concatenated;
}

int main(int argc, char *argv[])
{
    std::random_device rd;
    std::mt19937 gen( rd());

    constexpr int n = 8;
    constexpr int k = 1;
    constexpr int m = (1<<k);

    KeyPair<n,k> kp;
    auto pk = kp.getPublicKey();

    // T init
    std::array<std::array<BasicPermutation<n+m>, m>, n> T;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            T[i][j] = BasicPermutation<n+m>::transposition(i+1,n+j+1);

    // std::array<std::array<BasicPermutation<n+m>, n+m>, n> bigT;
    // for (int i = 0; i < n+m; i++)
    // {
    //     for (int j = 0; j < n+m; j++)
    //     {
    //         if (i < n || j > n)
    //             bigT[i][j] = BasicPermutation<n+m>();
    //         else
    //             bigT[i][j] = T[i-n][j-n];
    //     }
    // }
    // SimsGenerator<n+m> simsT(bigT);

    // mu init
    BasicPermutation<n+m> mu;
    for (int i = 0; i < n; i++)
        mu = mu * T[i][0];

    // gamma init
    BasicPermutation<n+m> gamma;
    for (int i = 0; i < n; i++)
        gamma = gamma * pk[i][0];

    // M init
    std::vector<BasicPermutation<n+m>> M = {BasicPermutation<n+m>()};
    for (auto row : T)
        M = M * std::vector<BasicPermutation<n+m>>(row.begin(),row.end());

    // C init
    std::vector<BasicPermutation<n+m>> C = {BasicPermutation<n+m>()};
    for (auto row : kp.getPublicKey())
        C = C * std::vector<BasicPermutation<n+m>>(row.begin(),row.end());

    // now bring to a more useful form
    M = M * std::vector<BasicPermutation<n+m>>{mu.inverse()};
    // the elements of M and C are conjugates now
    C = C * std::vector<BasicPermutation<n+m>>{gamma.inverse()};

    // We are interested in the group generated by M
    SimsGenerator<n+m> simsM;
    simsM.feed(zip<n+m>(M,C));
    while (simsM.hasNext())
        simsM.next();

    std::cout << simsM.group_size() << "\n\n";

    SimsGenerator<n+m> simsC;
    simsC.feed(mirror<n+m>(concatenateSquareMatrix<Permutation<n+m>,n+m>(simsM.getTable())));
    while (simsC.hasNext())
        simsC.next();

    int badopt = 0;
    int success = 0;
    int fail = 0;
    for (int r = 0; r < 256; r++)
    {
        // random message to encrypt then try to crack
        auto message = std::bitset<k*n>(r);
        // or better a random product from T
        std::array<int, n> messagevec;

        for (int i = 0; i < n; i++)
        {
            std::bitset<k> word;
            for (int j = 0; j < k; j++)
            {
                word[j] = message[i*k+j];
            }
            messagevec[i] = word.to_ulong()+1;
        }

        // encrypt the message
        auto code = kp.encrypt(message);
        // bring it to more useful form
        code = code * gamma.inverse();

        // find decomposition in simsC
        auto decomp = simsC.cascade(Permutation<n+m>(code,BasicPermutation<n+m>()), false);

        if (decomp.getPerm() != BasicPermutation<n+m>())
        {
            fail++;
            continue;
        }
        // find equivalent element by emulating the decomposition in simsM
        BasicPermutation<n+m> amuinv = decomp.getShadow().inverse();
        // bring back to initial form
        auto a = amuinv * mu;

        // // now we can find its decomposition in T
        // auto d = simsT.cascade(Permutation<n>(a, BasicPermutation<n+m>()));
        auto y = a.decompose_i<m>();

        // std::cout << y.has_value();
        if (!y.has_value())
        {
            std::cout << "badopt:\n" << a << "\n";
            badopt++;
            fail++;
            // std::cout << "badopt: " << r << "\n";
            continue;
        }
        success += (messagevec == y.value());
        fail += !(messagevec == y.value());
        // if (messagevec != y.value())
        // std::cout << "fail: " << r << "\n";

        // std::cout << (messagevec == y.value()) << "\n";
        // for (auto yi : messagevec)
        //     std::cout << yi-1 << ", ";
        // std::cout << "\n";
        // for (auto yi : y.value())
        //     std::cout << yi-1 << ", ";
    }
    std::cout << "\n\nbadopt: " << badopt << "\n success: " << success << "\n fail: " << fail;
    return 0;
}
